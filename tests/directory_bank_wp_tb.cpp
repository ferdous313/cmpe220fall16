
#include "Vdirectory_bank_wp.h"
#include "verilated.h"
#include "verilated_vcd_c.h"

#include <list>

#include <time.h>

#define DEBUG_TRACE 1

//Set which sets you want to run
//#define TEST_PFREQ 1
#define TEST_REQ 1
#define TEST_ACK 1
//#define TEST_DISP 1

#define DR_PASSTHROUGH 1

vluint64_t global_time = 0;
VerilatedVcdC* tfp = 0;


//Below is code from other tb
void advance_half_clock(Vdirectory_bank_wp *top) {
#ifdef TRACE
  tfp->dump(global_time);
#endif

  top->eval();
  top->clk = !top->clk;
  top->eval();

  global_time++;
  if (Verilated::gotFinish())  
    exit(0);
}

void advance_clock(Vdirectory_bank_wp *top, int nclocks=1) {

  for( int i=0;i<nclocks;i++) {
    for (int clk=0; clk<2; clk++) {
      advance_half_clock(top);
    }
  }
}

void sim_finish(bool pass) {
#ifdef TRACE
  tfp->close();
#endif

  if (pass)
    printf("\nTB:PASS\n");
  else
    printf("\nTB:FAILED\n");

  exit(0);
}

struct InputPacket_l2todr_pfreq {
  uint8_t  nid;
  uint64_t paddr;
};

struct OutputPacket_drtomem_pfreq {
  uint8_t  nid;
  uint64_t paddr; // read result
};

struct InputPacket_l2todr_disp {
  
  uint8_t      nid; 
  uint8_t      l2id;
  uint8_t      drid;

  uint64_t     mask; 
  uint8_t      dcmd;

  uint64_t     line_7;
  uint64_t     line_6;
  uint64_t     line_5;
  uint64_t     line_4;
  uint64_t     line_3;
  uint64_t     line_2;
  uint64_t     line_1;
  uint64_t     line_0;
  uint64_t     paddr;
};

struct OutputPacket_drtomem_wb {
  uint64_t     mask; // For NC disps

  //not testing full line for now
  uint64_t     line_7;
  uint64_t     line_6;
  uint64_t     line_5;
  uint64_t     line_4;
  uint64_t     line_3;
  uint64_t     line_2;
  uint64_t     line_1;
  uint64_t     line_0;
  uint64_t     paddr;
};

struct OutputPacket_drtol2_dack {
  uint8_t      nid; 
  uint8_t      l2id; 
};

struct InputPacket_l2todr_req {
  uint8_t nid;
  uint8_t l2id;
  uint8_t cmd;
  uint64_t paddr;
};

struct OutputPacket_drtomem_req {
  uint8_t drid;
  uint8_t cmd;
  uint64_t paddr; // read result
};

struct InputPacket_memtodr_ack {
  uint8_t drid;
  uint8_t nid;
  uint64_t paddr;
  uint8_t ack_cmd;
  uint64_t line_7;
  uint64_t line_6;
  uint64_t line_5;
  uint64_t line_4;
  uint64_t line_3;
  uint64_t line_2;
  uint64_t line_1;
  uint64_t line_0;
};

//I dont have a good system to edit packets after they have been pushed (would need some type of vector rather than list)
//So I will just check two output packets for the snack. One contains the l2id and nid sent on the request and the other 
//contains the data generated by the memtodr_ack.
struct OutputPacket_drtol2_ack_ids {
  uint8_t nid;
  uint8_t l2id;
};

struct OutputPacket_drtol2_snack {
  uint8_t nid;
  uint8_t l2id;
  uint8_t drid;
  uint8_t directory_id;
  uint8_t ack_cmd;
  uint64_t paddr; // read result
  uint64_t line_7;
  uint64_t line_6;
  uint64_t line_5;
  uint64_t line_4;
  uint64_t line_3;
  uint64_t line_2;
  uint64_t line_1;
  uint64_t line_0;
  
};

struct InputPacket_l2todr_snoop_ack {
  uint8_t drid;
  uint8_t directory_id;
};



double sc_time_stamp() {
  return 0;
}

uint16_t memory[256];

std::list<InputPacket_l2todr_pfreq>  inp_list_pfreq;
std::list<OutputPacket_drtomem_pfreq> out_list_pfreq;

std::list<InputPacket_l2todr_req>  inp_list_req;
std::list<OutputPacket_drtomem_req> out_list_req;

std::list<InputPacket_memtodr_ack>  inp_list_ack;
std::list<OutputPacket_drtol2_snack> out_list_ack;
std::list<OutputPacket_drtol2_ack_ids> out_list_ack_ids;

std::list<InputPacket_l2todr_disp>  inp_list_disp;
std::list<OutputPacket_drtol2_dack> out_list_dack;
std::list<OutputPacket_drtomem_wb> out_list_wb;

std::list<InputPacket_l2todr_snoop_ack>  inp_list_snoop_ack;

void error_found(Vdirectory_bank_wp *top) {
  advance_half_clock(top);
  advance_half_clock(top);
  sim_finish(false);
}

void try_send_packet(Vdirectory_bank_wp *top) {
  
  //pfreq
  top->drtomem_pfreq_retry = (rand()&0x3F)==0; 

  if (!top->l2todr_pfreq_retry) {
    top->l2todr_pfreq_paddr = rand();
    if (inp_list_pfreq.empty() || (rand() & 0x3)) { // Once every 4
      top->l2todr_pfreq_valid = 0;
    }else{
      top->l2todr_pfreq_valid = 1;
    }
  }
  
  //req
  top->drtomem_req_retry = (rand()&0x3F)==0; 

  if (!top->l2todr_req_retry) {
    top->l2todr_req_paddr = rand();
    if (inp_list_req.empty() || (rand() & 0x3)) { // Once every 4
      top->l2todr_req_valid = 0;
    }else{
      top->l2todr_req_valid = 1;
    }
  }
  
  //disp
  top->drtomem_wb_retry = (rand()&0x3F)==0; 
  top->drtol2_dack_retry = (rand()&0x3F)==0; 

  if (!top->l2todr_disp_retry) {
    top->l2todr_req_paddr = rand();
    if (inp_list_disp.empty() || (rand() & 0x3)) { // Once every 4
      top->l2todr_disp_valid = 0;
    }else{
      top->l2todr_disp_valid = 1;
    }
  }
  
  //l2todr snoop ack
  if (!top->l2todr_snoop_ack_retry) {
    top->l2todr_req_paddr = rand();
    if (inp_list_snoop_ack.empty() || (rand() & 0x3)) { // Once every 4
      top->l2todr_snoop_ack_valid = 0;
    }else{
      top->l2todr_snoop_ack_valid = 1;
    }
  }
  

  
  //ack
  top->drtol2_snack_retry = (rand()&0x3F)==0; 

  if (!top->memtodr_ack_retry) {
    top->memtodr_ack_line_7 = rand();
    top->memtodr_ack_line_6 = rand();
    top->memtodr_ack_line_5 = rand();
    top->memtodr_ack_line_4 = rand();
    top->memtodr_ack_line_3 = rand();
    top->memtodr_ack_line_2 = rand();
    top->memtodr_ack_line_1 = rand();
    top->memtodr_ack_line_0 = rand();
    
    if (inp_list_ack.empty() || (rand() & 0x3)) { // Once every 4
      top->memtodr_ack_valid = 0;
    }else{
      top->memtodr_ack_valid = 1;
    }
  }
  
  //Code that sends the messages starts here. Previous code was just setting valids and retries.
  //pfreq message send
  if (top->l2todr_pfreq_valid && !top->l2todr_pfreq_retry) {
    if (inp_list_pfreq.empty()) {
      fprintf(stderr,"ERROR: Internal error, could not be empty inpa\n");
      error_found(top);
    }


    InputPacket_l2todr_pfreq inp1 = inp_list_pfreq.back();
    top->l2todr_pfreq_paddr = inp1.paddr;
    top->l2todr_pfreq_nid = inp1.nid;
#ifdef DEBUG_TRACE
    printf("@%lu pfreq paddr:%lu, nid: %u \n",global_time, inp1.paddr, inp1.nid);
#endif
   
    inp_list_pfreq.pop_back();
  }
  
  //req
  if (top->l2todr_req_valid && !top->l2todr_req_retry) {
    if (inp_list_req.empty()) {
      fprintf(stderr,"ERROR: Internal error, could not be empty inpa\n");
      error_found(top);
    }


    InputPacket_l2todr_req inp2 = inp_list_req.back();
    top->l2todr_req_paddr = inp2.paddr;
    top->l2todr_req_cmd = inp2.cmd;
    top->l2todr_req_nid = inp2.nid;
    top->l2todr_req_l2id = inp2.l2id;
#ifdef DEBUG_TRACE
    printf("@%lu l2todr req paddr:%lu, cmd: %u, nid: %u, l2id: %u\n",global_time, inp2.paddr,inp2.cmd, inp2.nid, inp2.l2id);
#endif
   
    OutputPacket_drtomem_req out2;
    out2.paddr = inp2.paddr;
    out2.cmd = inp2.cmd;
    //Not pusing output packets currently because the directory will not always send a request to memory.
#ifdef DR_PASSTHROUGH
    out_list_req.push_front(out2);
#endif

    inp_list_req.pop_back();
  }
  
  //disp
  if (top->l2todr_disp_valid && !top->l2todr_disp_retry) {
    if (inp_list_disp.empty()) {
      fprintf(stderr,"ERROR: Internal error, could not be empty inpa\n");
      error_found(top);
    }


    InputPacket_l2todr_disp inp_disp   = inp_list_disp.back();
    top->l2todr_disp_paddr = inp_disp.paddr;
    top->l2todr_disp_nid = inp_disp.nid;
    top->l2todr_disp_l2id = inp_disp.l2id;
    
    top->l2todr_disp_mask = inp_disp.mask;
    top->l2todr_disp_line_7 = inp_disp.line_7;
    top->l2todr_disp_line_6 = inp_disp.line_6;
    top->l2todr_disp_line_5 = inp_disp.line_5;
    top->l2todr_disp_line_4 = inp_disp.line_4;
    top->l2todr_disp_line_3 = inp_disp.line_3;
    top->l2todr_disp_line_2 = inp_disp.line_2;
    top->l2todr_disp_line_1 = inp_disp.line_1;
    top->l2todr_disp_line_0 = inp_disp.line_0;
    top->l2todr_disp_drid = inp_disp.drid;
    top->l2todr_disp_dcmd = inp_disp.dcmd;
#ifdef DEBUG_TRACE
    printf("@%lu l2todr disp paddr: %lu, nid: %u, l2id:%u , mask:%lu , drid:%u , dcmd:%u, data:%lu %lu %lu %lu %lu %lu %lu %lu\n"
                                                                                  ,global_time
                                                                                  ,inp_disp.paddr
                                                                                  ,inp_disp.nid
                                                                                  ,inp_disp.l2id
                                                                                  ,inp_disp.mask
                                                                                  ,inp_disp.drid
                                                                                  ,inp_disp.dcmd
                                                                                  ,inp_disp.line_7
                                                                                  ,inp_disp.line_6
                                                                                  ,inp_disp.line_5
                                                                                  ,inp_disp.line_4
                                                                                  ,inp_disp.line_3
                                                                                  ,inp_disp.line_2
                                                                                  ,inp_disp.line_1
                                                                                  ,inp_disp.line_0);
#endif
     

    inp_list_disp.pop_back();
  }
  
  //ack
  if (top->memtodr_ack_valid && !top->memtodr_ack_retry) {
    if (inp_list_ack.empty()) {
      fprintf(stderr,"ERROR: Internal error, could not be empty inpa\n");
      error_found(top);
    }

#ifdef TEST_ACK
    

    InputPacket_memtodr_ack inp3 = inp_list_ack.back();
    top->memtodr_ack_drid = inp3.drid;
    top->memtodr_ack_ack = inp3.ack_cmd;
    top->memtodr_ack_nid = inp3.nid;
    top->memtodr_ack_paddr = inp3.paddr;
    top->memtodr_ack_line_7 = inp3.line_7;
    top->memtodr_ack_line_6 = inp3.line_6;
    top->memtodr_ack_line_5 = inp3.line_5;
    top->memtodr_ack_line_4 = inp3.line_4;
    top->memtodr_ack_line_3 = inp3.line_3;
    top->memtodr_ack_line_2 = inp3.line_2;
    top->memtodr_ack_line_1 = inp3.line_1;
    top->memtodr_ack_line_0 = inp3.line_0;

#ifdef DEBUG_TRACE
    printf("@%lu memtodr ack paddr: %lu, nid: %u, drid: %u, ack_cmd: %u, data:%lu,%lu,%lu,%lu,%lu,%lu,%lu,%lu\n"
                                                                             ,global_time 
                                                                             ,inp3.paddr
                                                                             ,inp3.nid
                                                                             ,inp3.drid 
                                                                             ,inp3.ack_cmd
                                                                             ,inp3.line_7
                                                                             ,inp3.line_6
                                                                             ,inp3.line_5
                                                                             ,inp3.line_4
                                                                             ,inp3.line_3
                                                                             ,inp3.line_2
                                                                             ,inp3.line_1
                                                                             ,inp3.line_0
                                                                             ); //change
#endif
   

    
    
    
#endif    



    inp_list_ack.pop_back();
  }
  
  //l2todr snoop ack
  if (top->l2todr_snoop_ack_valid && !top->l2todr_snoop_ack_retry) {
    if (inp_list_snoop_ack.empty()) {
      fprintf(stderr,"ERROR: Internal error, could not be empty inpa\n");
      error_found(top);
    }


    InputPacket_l2todr_snoop_ack inp = inp_list_snoop_ack.back();
    top->l2todr_snoop_ack_drid = inp.drid;
    top->l2todr_snoop_ack_directory_id = inp.directory_id;
#ifdef DEBUG_TRACE
    printf("@%lu l2todr snoop ack drid: %u, Directory ID: %u\n",global_time, inp.drid, inp.directory_id);
#endif

    inp_list_snoop_ack.pop_back();
  }

}

//above is code from other tb
void try_recv_packet_pfreq(Vdirectory_bank_wp *top) {

  //pfreq
  if (top->drtomem_pfreq_valid && out_list_pfreq.empty()) {
    printf("ERROR: unexpected drtomem pfreq paddr:%lu, nid: %u\n",top->drtomem_pfreq_paddr, top->drtomem_pfreq_nid);
    error_found(top);
    return;
  }

  if (top->drtomem_pfreq_retry)
    return;

  if (!top->drtomem_pfreq_valid)
    return;

  if (out_list_pfreq.empty())
    return;

#ifdef DEBUG_TRACE
    printf("@%lu drtomem pfreq paddr:%lu, nid: %u\n",global_time, top->drtomem_pfreq_paddr, top->drtomem_pfreq_nid);
#endif
  OutputPacket_drtomem_pfreq o = out_list_pfreq.back();
  if (top->drtomem_pfreq_paddr != o.paddr) {
    printf("ERROR: expected drtomem paddr:%lu but actual is %lu\n",o.paddr,top->drtomem_pfreq_paddr);
    error_found(top);
  } else if (top->drtomem_pfreq_nid != o.nid) {
    printf("ERROR: expected drtomem nid:%u but actual is %u\n",o.nid,top->drtomem_pfreq_nid);
    error_found(top);
  }
  
  //Randomly choose for a prefetch acknowledgement to occur
  if(rand() % 5){
        InputPacket_memtodr_ack i_ack;
        i_ack.drid = 0;
        i_ack.nid = o.nid;
        i_ack.paddr = o.paddr;
        i_ack.ack_cmd = 4;
        i_ack.line_7 = rand() & 0xFFFFFFFFFFFFFFFF;
        i_ack.line_6 = rand() & 0xFFFFFFFFFFFFFFFF;
        i_ack.line_5 = rand() & 0xFFFFFFFFFFFFFFFF;
        i_ack.line_4 = rand() & 0xFFFFFFFFFFFFFFFF;
        i_ack.line_3 = rand() & 0xFFFFFFFFFFFFFFFF;
        i_ack.line_2 = rand() & 0xFFFFFFFFFFFFFFFF;
        i_ack.line_1 = rand() & 0xFFFFFFFFFFFFFFFF;
        i_ack.line_0 = rand() & 0xFFFFFFFFFFFFFFFF;
        inp_list_ack.push_front(i_ack);
               
        OutputPacket_drtol2_snack o_ack;
        o_ack.drid = i_ack.drid;
        o_ack.nid = i_ack.nid;
        o_ack.l2id = 0;
        o_ack.directory_id = 0; //not defined in the verilog code currently
        o_ack.paddr = i_ack.paddr;
        o_ack.ack_cmd = i_ack.ack_cmd;
        o_ack.line_7 = i_ack.line_7;
        o_ack.line_6 = i_ack.line_6;
        o_ack.line_5 = i_ack.line_5;
        o_ack.line_4 = i_ack.line_4;
        o_ack.line_3 = i_ack.line_3;
        o_ack.line_2 = i_ack.line_2;
        o_ack.line_1 = i_ack.line_1;
        o_ack.line_0 = i_ack.line_0;
        out_list_ack.push_front(o_ack);
  }

  out_list_pfreq.pop_back();
  
}

void try_recv_packet_wb(Vdirectory_bank_wp *top) {

  //wb
  if (top->drtomem_wb_valid && out_list_wb.empty()) {
    printf("ERROR: unexpected drtomem wb paddr: %lu, mask:%lu, data:%lu %lu %lu %lu %lu %lu %lu %lu\n"
                                                                                  ,top->drtomem_wb_paddr
                                                                                  ,top->drtomem_wb_mask
                                                                                  ,top->drtomem_wb_line_7
                                                                                  ,top->drtomem_wb_line_6
                                                                                  ,top->drtomem_wb_line_5
                                                                                  ,top->drtomem_wb_line_4
                                                                                  ,top->drtomem_wb_line_3
                                                                                  ,top->drtomem_wb_line_2
                                                                                  ,top->drtomem_wb_line_1
                                                                                  ,top->drtomem_wb_line_0);
    error_found(top);
    return;
  }

  if (top->drtomem_wb_retry)
    return;

  if (!top->drtomem_wb_valid)
    return;

  if (out_list_wb.empty())
    return;

#ifdef DEBUG_TRACE
    printf("@%lu drtomem wb paddr: %lu, mask:%lu, data:%lu %lu %lu %lu %lu %lu %lu %lu\n",global_time
                                                                                         ,top->drtomem_wb_paddr
                                                                                         ,top->drtomem_wb_mask
                                                                                         ,top->drtomem_wb_line_7
                                                                                         ,top->drtomem_wb_line_6
                                                                                         ,top->drtomem_wb_line_5
                                                                                         ,top->drtomem_wb_line_4
                                                                                         ,top->drtomem_wb_line_3
                                                                                         ,top->drtomem_wb_line_2
                                                                                         ,top->drtomem_wb_line_1
                                                                                         ,top->drtomem_wb_line_0);
#endif
  OutputPacket_drtomem_wb o = out_list_wb.back();
  if (top->drtomem_wb_paddr != o.paddr) {
    printf("ERROR: expected drtomem wb paddr:%lu but actual is %lu\n",o.paddr,top->drtomem_wb_paddr);
    error_found(top);
  } else if(top->drtomem_wb_mask != o.mask){
    printf("ERROR: expected drtomem wb mask:%lu but wb is %lu\n",o.mask,top->drtomem_wb_mask);
    error_found(top);
  } else if(top->drtomem_wb_line_7 != o.line_7){
    printf("ERROR: expected drtomem wb data_7:%lu but wb is %lu\n",o.line_7,top->drtomem_wb_line_7);
    error_found(top);
  } else if(top->drtomem_wb_line_6 != o.line_6){
    printf("ERROR: expected drtomem wb data_6:%lu but wb is %lu\n",o.line_6,top->drtomem_wb_line_6);
    error_found(top);
  } else if(top->drtomem_wb_line_5 != o.line_5){
    printf("ERROR: expected drtomem wb data_5:%lu but wb is %lu\n",o.line_5,top->drtomem_wb_line_5);
    error_found(top);
  } else if(top->drtomem_wb_line_4 != o.line_4){
    printf("ERROR: expected drtomem wb data_4:%lu but wb is %lu\n",o.line_4,top->drtomem_wb_line_4);
    error_found(top);
  } else if(top->drtomem_wb_line_3 != o.line_3){
    printf("ERROR: expected drtomem wb data_3:%lu but wb is %lu\n",o.line_3,top->drtomem_wb_line_3);
    error_found(top);
  } else if(top->drtomem_wb_line_2 != o.line_2){
    printf("ERROR: expected drtomem wb data_2:%lu but wb is %lu\n",o.line_2,top->drtomem_wb_line_2);
    error_found(top);
  } else if(top->drtomem_wb_line_1 != o.line_1){
    printf("ERROR: expected drtomem wb data_1:%lu but wb is %lu\n",o.line_1,top->drtomem_wb_line_1);
    error_found(top);
  } else if(top->drtomem_wb_line_0 != o.line_0){
    printf("ERROR: expected drtomem wb data_0:%lu but wb is %lu\n",o.line_0,top->drtomem_wb_line_0);
    error_found(top);
  }

  out_list_wb.pop_back();
  
}

void try_recv_packet_dack(Vdirectory_bank_wp *top) {

  //dack
  if (top->drtol2_dack_valid && out_list_dack.empty()) {
    printf("ERROR: unexpected drtol2 dack nid: %u, l2id:%u\n",top->drtol2_dack_nid, top->drtol2_dack_l2id);
    error_found(top);
    return;
  }

  if (top->drtol2_dack_retry)
    return;

  if (!top->drtol2_dack_valid)
    return;

  if (out_list_dack.empty())
    return;

#ifdef DEBUG_TRACE
    printf("@%lu drtol2 dack nid:%u, l2id:%u\n",global_time, top->drtol2_dack_nid, top->drtol2_dack_l2id);
#endif
  OutputPacket_drtol2_dack o = out_list_dack.back();
  if (top->drtol2_dack_nid != o.nid) {
    printf("ERROR: expected drtol2 dack nid:%u but actual is %u\n",o.nid,top->drtol2_dack_nid);
    error_found(top);
  } else if (top->drtol2_dack_l2id != o.l2id) {
    printf("ERROR: expected drtol2 dack l2id:%u but actual is %u\n",o.l2id,top->drtol2_dack_l2id);
    error_found(top);
  }

  out_list_dack.pop_back();
  
}

void try_recv_packet_req(Vdirectory_bank_wp *top) {

  //req
#ifdef DR_PASSTHROUGH
  if (top->drtomem_req_valid && out_list_req.empty()) {
    printf("ERROR: unexpected drtomem req paddr:%lu\n",top->drtomem_req_paddr);
    error_found(top);
    return;
  }
#endif

  if (top->drtomem_req_retry)
    return;

  if (!top->drtomem_req_valid)
    return;


#ifdef DEBUG_TRACE
    printf("@%lu drtomem req paddr:%lu, drid: %u, cmd: %u\n",global_time, top->drtomem_req_paddr, top->drtomem_req_drid, top->drtomem_req_cmd);
#endif

#ifdef DR_PASSTHROUGH
  if (out_list_req.empty())
    return;

  OutputPacket_drtomem_req o2 = out_list_req.back();
  if (top->drtomem_req_paddr != o2.paddr) {
    printf("ERROR: expected drtomem paddr:%lu but actual is %lu\n",o2.paddr,top->drtomem_req_paddr);
    error_found(top);
  } else if (top->drtomem_req_cmd != o2.cmd) {
    printf("ERROR: expected drtomem cmd:%u but actual is %u\n",o2.cmd,top->drtomem_req_cmd);
    error_found(top);
  }
  
  out_list_req.pop_back();
#endif
  
#ifdef TEST_ACK
  //When we receive a request, push an ack
  
  InputPacket_memtodr_ack inAck;    
  inAck.line_7 = rand();
  inAck.line_6 = rand();
  inAck.line_5 = rand();
  inAck.line_4 = rand();
  inAck.line_3 = rand();
  inAck.line_2 = rand();
  inAck.line_1 = rand();
  inAck.line_0 = rand();
  inAck.drid = top->drtomem_req_drid;
  inAck.nid = 0;
  inAck.paddr = 0;
  inAck.ack_cmd = rand() & 0x1B; //this prevents prefetch command from being generated.
  inp_list_ack.push_front(inAck);
  
  OutputPacket_drtol2_snack out3;    
  out3.line_7 = inAck.line_7;
  out3.line_6 = inAck.line_6;
  out3.line_5 = inAck.line_5;
  out3.line_4 = inAck.line_4;
  out3.line_3 = inAck.line_3;
  out3.line_2 = inAck.line_2;
  out3.line_1 = inAck.line_1;
  out3.line_0 = inAck.line_0;
  out3.drid = 0;
  out3.directory_id = 0;
  out3.ack_cmd = inAck.ack_cmd;
  out3.paddr = 0;
  
#ifdef DR_PASSTHROUGH
  OutputPacket_drtol2_ack_ids o_id = out_list_ack_ids.back();
  out3.nid = o_id.nid;
  out3.l2id = o_id.l2id;
  out_list_ack_ids.pop_back();
#else
  out3.nid = 0;
  out3.l2id = 0;
#endif 
  out_list_ack.push_front(out3);
  
#endif
  
  
}

//ack
void try_recv_packet_ack(Vdirectory_bank_wp *top) {

  //The ack list only maintains acks and not snoops. If the DRID is not 0 then this is a snoop and we can ignore
  //the error condition where there are no items in our list.
  if (top->drtol2_snack_valid && out_list_ack.empty() && top->drtol2_snack_drid == 0) {
    printf("ERROR: unexpected drtol2 ack nid: %u, l2id: %u, data:%lu,%lu,%lu,%lu,%lu,%lu,%lu,%lu\n"
                                                                             ,top->drtol2_snack_nid
                                                                             ,top->drtol2_snack_l2id
                                                                             ,top->drtol2_snack_line_7
                                                                             ,top->drtol2_snack_line_6
                                                                             ,top->drtol2_snack_line_5
                                                                             ,top->drtol2_snack_line_4
                                                                             ,top->drtol2_snack_line_3
                                                                             ,top->drtol2_snack_line_2
                                                                             ,top->drtol2_snack_line_1
                                                                             ,top->drtol2_snack_line_0); //change
    error_found(top);
    return;
  }

  if (top->drtol2_snack_retry)
    return;

  if (!top->drtol2_snack_valid)
    return;

  if (out_list_ack.empty() && top->drtol2_snack_drid == 0)
    return;
  
  //This is the case of the snack being a snoop rather than an ack. In this case, we want to send a snoop ack which implies
  //that the Testbench is not sending data as a response to this ack and just acking instead.
  

#ifdef DEBUG_TRACE
  printf("@%lu drtol2 ack paddr: %lu, nid: %u, l2id: %u, drid: %u, directory_id: %u, snack_cmd: %u, data:%lu,%lu,%lu,%lu,%lu,%lu,%lu,%lu\n",global_time 
                                                                             ,top->drtol2_snack_paddr
                                                                             ,top->drtol2_snack_nid
                                                                             ,top->drtol2_snack_l2id
                                                                             ,top->drtol2_snack_drid
                                                                             ,top->drtol2_snack_directory_id
                                                                             ,top->drtol2_snack_snack
                                                                             ,top->drtol2_snack_line_7
                                                                             ,top->drtol2_snack_line_6
                                                                             ,top->drtol2_snack_line_5
                                                                             ,top->drtol2_snack_line_4
                                                                             ,top->drtol2_snack_line_3
                                                                             ,top->drtol2_snack_line_2
                                                                             ,top->drtol2_snack_line_1
                                                                             ,top->drtol2_snack_line_0); //change
#endif

  if(top->drtol2_snack_drid != 0){
    InputPacket_l2todr_snoop_ack i;
    i.drid = top->drtol2_snack_drid;
    i.directory_id = top->drtol2_snack_directory_id;
    inp_list_snoop_ack.push_front(i);
    return;
  }


  OutputPacket_drtol2_snack o = out_list_ack.back();
  if (top->drtol2_snack_line_7 != o.line_7) {
    printf("ERROR: expected drtol2 ack data:%lu but ack is %lu\n",o.line_7,top->drtol2_snack_line_7);
    error_found(top);
  } else if (top->drtol2_snack_line_6 != o.line_6) {
    printf("ERROR: expected drtol2 ack data:%lu but ack is %lu\n",o.line_6,top->drtol2_snack_line_6);
    error_found(top);
  } else if (top->drtol2_snack_line_5 != o.line_5) {
    printf("ERROR: expected drtol2 ack data:%lu but ack is %lu\n",o.line_5,top->drtol2_snack_line_5);
    error_found(top);
  } else if (top->drtol2_snack_line_4 != o.line_4) {
    printf("ERROR: expected drtol2 ack data:%lu but ack is %lu\n",o.line_4,top->drtol2_snack_line_4);
    error_found(top);
  } else if (top->drtol2_snack_line_3 != o.line_3) {
    printf("ERROR: expected drtol2 ack data:%lu but ack is %lu\n",o.line_3,top->drtol2_snack_line_3);
    error_found(top);
  } else if (top->drtol2_snack_line_2 != o.line_2) {
    printf("ERROR: expected drtol2 ack data:%lu but ack is %lu\n",o.line_2,top->drtol2_snack_line_2);
    error_found(top);
  } else if (top->drtol2_snack_line_1 != o.line_1) {
    printf("ERROR: expected drtol2 ack data:%lu but ack is %lu\n",o.line_1,top->drtol2_snack_line_1);
    error_found(top);
  } else if (top->drtol2_snack_line_0 != o.line_0) {
    printf("ERROR: expected drtol2 ack data:%lu but ack is %lu\n",o.line_0,top->drtol2_snack_line_0);
    error_found(top);
  }
  
#ifdef DR_PASSTHROUGH
  if (top->drtol2_snack_nid != o.nid) {
    printf("ERROR: expected drtol2 ack nid:%u but actual is %u\n",o.nid,top->drtol2_snack_nid);
    error_found(top);
  } else if (top->drtol2_snack_l2id != o.l2id) {
    printf("ERROR: expected drtol2 ack l2id:%u but actual is %u\n",o.l2id,top->drtol2_snack_l2id);
    error_found(top);
  } 
#endif

  if (top->drtol2_snack_drid != o.drid) {
    printf("ERROR: expected drtol2 ack drid:%u but actual is %u\n",o.drid,top->drtol2_snack_drid);
    error_found(top);
  } else if (top->drtol2_snack_directory_id != o.directory_id) {
    printf("ERROR: expected drtol2 ack directory_id:%u but actual is %u\n",o.directory_id,top->drtol2_snack_directory_id);
    error_found(top);
  } else if (top->drtol2_snack_snack != o.ack_cmd) {
    printf("ERROR: expected drtol2 ack snack :%u but actual is %u\n",o.ack_cmd,top->drtol2_snack_snack );
    error_found(top);
  } else if (top->drtol2_snack_paddr != o.paddr) {
    printf("ERROR: expected drtol2 ack paddr:%lu but actual is %lu\n",o.paddr,top->drtol2_snack_paddr);
    error_found(top);
  }
  

  out_list_ack.pop_back();
}




int main(int argc, char **argv, char **env) {
  int i;
  int clk;
  Verilated::commandArgs(argc, argv);
  // init top verilog instance
  Vdirectory_bank_wp *top = new Vdirectory_bank_wp;

  int t = (int)time(0);
#if 0
  srand(1477551033);
#else
  srand(t);
#endif
  printf("My RAND Seed is %d\n",t);

#ifdef TRACE
  // init trace dump
  Verilated::traceEverOn(true);
  tfp = new VerilatedVcdC;

  top->trace(tfp, 99);
  tfp->open("output.vcd");
#endif

  // initialize simulation inputs
  top->clk = 1;
  top->reset = 1;

  advance_clock(top,1024);  // Long reset to give time to the state machine
  //-------------------------------------------------------
  top->reset = 0;
  top->drtomem_pfreq_retry = 1;
  top->drtomem_req_retry = 1;
  
  top->drtol2_snack_retry = 1;
  top->memtodr_ack_valid = 0;

  
  top->l2todr_req_nid = 0;
  top->l2todr_req_l2id = 0;
  top->l2todr_req_cmd = 0;
  //First test: only test a single set of signals like the l2 to dr or even prefetch
  //Associate retry signal with one I am testing.... prefetch it is.
  advance_clock(top,1);

  
  //I think I have given up converting this and it will be easier writing my own testbench.
  //I could actually use the code, but I have to alter the send packet function.

#if 1
  for(int i =0;i<10240;i++) {
    try_send_packet(top);
    advance_half_clock(top);
    
#ifdef TEST_PFREQ
    try_recv_packet_pfreq(top);
#endif

#ifdef TEST_REQ
    try_recv_packet_req(top);
#endif

#ifdef TEST_DISP
    try_recv_packet_wb(top);
    try_recv_packet_dack(top);
#endif

#ifdef TEST_ACK    
    try_recv_packet_ack(top);
#endif
    advance_half_clock(top);
    
#ifdef TEST_PFREQ
    if (((rand() & 0x3)==0) && inp_list_pfreq.size() < 3 ) {
      InputPacket_l2todr_pfreq i;
      i.nid = rand() & 0x1F;

      if (rand() % 3)
        i.paddr = rand() & 0x0001FFFFFFFFFFFF;
      else if (!inp_list_pfreq.empty())
        i.paddr = inp_list_pfreq.front().paddr;
      else
        i.paddr = rand() & 0x00000000FFFFFFFF;

      inp_list_pfreq.push_front(i);
      
      OutputPacket_drtomem_pfreq o;
      o.paddr = i.paddr;
      o.nid = i.nid;
      out_list_pfreq.push_front(o);
         
    }
#endif
    
#ifdef TEST_REQ  
    if (((rand() & 0x3)==0) && inp_list_req.size() < 3 ) {
      InputPacket_l2todr_req i;
      int pick_cmd = rand()%4;

      i.nid = rand() & 0x1F;
      i.l2id = (rand()%63) + 1; //in the range 1-63
      
      if(pick_cmd == 0)
        i.cmd = 0x0; //get shared
      else if(pick_cmd == 1)
        i.cmd = 0x1; //get exclusive
      else
        i.cmd = 0x2; //get NC
      
      if (rand() % 3)
        i.paddr = rand() & 0x0001FFFFFFFFFFFF;
      else if (!inp_list_req.empty())
        i.paddr = inp_list_req.front().paddr;
      else
        i.paddr = rand() & 0x00000000FFFFFFFF;

      inp_list_req.push_front(i);
      
      OutputPacket_drtol2_ack_ids o;
      o.nid = i.nid;
      o.l2id = i.l2id;
#ifdef DR_PASSTHROUGH
      out_list_ack_ids.push_front(o);
#endif
    }
#endif


#ifdef TEST_DISP  
    if (((rand() & 0x3)==0) && inp_list_req.size() < 3 ) {
      InputPacket_l2todr_disp i;
      int pick_cmd = rand()%4;
      
      i.nid = rand() & 0x1F;
      i.l2id = rand() & 0x3F;
      
      if(pick_cmd == 0)
        i.dcmd = 0x0; //wb invalidated
      else if(pick_cmd == 1)
        i.dcmd = 0x1; //wb shared
      else if(pick_cmd == 2)
        i.dcmd = 0x2; //no wb
      else
        i.dcmd = 0x4; //wb NC
      
      i.drid = 0;
      i.mask = 0;
      i.line_7 = rand() & 0xFFFFFFFFFFFFFFFF;
      i.line_6 = rand() & 0xFFFFFFFFFFFFFFFF;
      i.line_5 = rand() & 0xFFFFFFFFFFFFFFFF;
      i.line_4 = rand() & 0xFFFFFFFFFFFFFFFF;
      i.line_3 = rand() & 0xFFFFFFFFFFFFFFFF;
      i.line_2 = rand() & 0xFFFFFFFFFFFFFFFF;
      i.line_1 = rand() & 0xFFFFFFFFFFFFFFFF;
      i.line_0 = rand() & 0xFFFFFFFFFFFFFFFF;
      if (rand() % 3)
        i.paddr = rand() & 0x0001FFFFFFFFFFFF;
      else if (!inp_list_req.empty())
        i.paddr = inp_list_req.front().paddr;
      else
        i.paddr = rand() & 0x00000000FFFFFFFF;

      inp_list_disp.push_front(i);
      
      
      OutputPacket_drtol2_dack o_dack;
      o_dack.nid = i.nid;
      o_dack.l2id = i.l2id;
      out_list_dack.push_front(o_dack);
      
      if(i.dcmd != 2){
        OutputPacket_drtomem_wb o_wb;
        o_wb.line_7 = i.line_7;
        o_wb.line_6 = i.line_6;
        o_wb.line_5 = i.line_5;
        o_wb.line_4 = i.line_4;
        o_wb.line_3 = i.line_3;
        o_wb.line_2 = i.line_2;
        o_wb.line_1 = i.line_1;
        o_wb.line_0 = i.line_0;
        o_wb.paddr = i.paddr;
        o_wb.mask = i.mask;
        out_list_wb.push_front(o_wb);
      }
    }
#endif
    //Ack does not have one of these because every push from from the response to a request
    
  }
#endif

  sim_finish(true);

}

